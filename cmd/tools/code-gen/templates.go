package main

var (
	headerTemplate = `{{ .Boilerplate }}

// Code generated by Mattermost cloud code-gen. DO NOT EDIT
package {{ .Package }}
`
	storeLockTemplate = `
{{range $i, $struct := .StructName}}
// Lock{{ index $.StructName $i }} marks the {{ index $.StructName $i }} as locked for exclusive use by the caller.
func (sqlStore *SQLStore) Lock{{ index $.StructName $i }}(id, lockerID string) (bool, error) {
	return sqlStore.lockRows("{{ index $.TableName $i }}", []string{id}, lockerID)
}

// Lock{{ index $.PluralName $i }} marks {{ index $.PluralName $i }} as locked for exclusive use by the caller.
func (sqlStore *SQLStore) Lock{{ index $.PluralName $i }}(ids []string, lockerID string) (bool, error) {
	return sqlStore.lockRows("{{ index $.TableName $i }}", ids, lockerID)
}

// Unlock{{ index $.StructName $i }} releases a lock previously acquired against a caller.
func (sqlStore *SQLStore) Unlock{{ index $.StructName $i }}(id, lockerID string, force bool) (bool, error) {
	return sqlStore.unlockRows("{{ index $.TableName $i }}", []string{id}, lockerID, force)
}

// Unlock{{ index $.PluralName $i }} releases a locks previously acquired against a caller.
func (sqlStore *SQLStore) Unlock{{ index $.PluralName $i }}(ids []string, lockerID string, force bool) (bool, error) {
	return sqlStore.unlockRows("{{ index $.TableName $i }}", ids, lockerID, force)
}
{{end}}
`

	supervisorLocksTemplate = `
{{range $i, $struct := .StructName}}

type {{ index $.StructNameNotExported $i }}LockStore interface {
	Lock{{ index $.PluralName $i }}(id []string, lockerID string) (bool, error)
	Unlock{{ index $.PluralName $i }}(id []string, lockerID string, force bool) (bool, error)
}

type {{ index $.StructNameNotExported $i }}Lock struct {
	ids []string
	lockerID               string
	store                  {{ index $.StructNameNotExported $i }}LockStore
	logger                 log.FieldLogger
}

func new{{ index $.StructName $i }}Lock(id, lockerID string, store {{ index $.StructNameNotExported $i }}LockStore, logger log.FieldLogger) *{{ index $.StructNameNotExported $i }}Lock {
	return &{{ index $.StructNameNotExported $i }}Lock{
		ids: []string{id},
		lockerID:               lockerID,
		store:                  store,
		logger:                 logger,
	}
}

func new{{ index $.StructName $i }}Locks(ids []string, lockerID string, store {{ index $.StructNameNotExported $i }}LockStore, logger log.FieldLogger) *{{ index $.StructNameNotExported $i }}Lock {
	return &{{ index $.StructNameNotExported $i }}Lock{
		ids: ids,
		lockerID:               lockerID,
		store:                  store,
		logger:                 logger,
	}
}

func (l *{{ index $.StructNameNotExported $i }}Lock) TryLock() bool {
	locked, err := l.store.Lock{{ index $.PluralName $i }}(l.ids, l.lockerID)
	if err != nil {
		l.logger.WithError(err).Error("failed to lock {{ index $.StructNameNotExportedPlural $i }}")
		return false
	}

	return locked
}

func (l *{{ index $.StructNameNotExported $i }}Lock) Unlock() {
	unlocked, err := l.store.Unlock{{ index $.PluralName $i }}(l.ids, l.lockerID, false)
	if err != nil {
		l.logger.WithError(err).Error("failed to unlock {{ index $.StructNameNotExportedPlural $i }}")
	} else if unlocked != true {
		l.logger.Error("failed to release lock for {{ index $.StructNameNotExportedPlural $i }}")
	}
}
{{end}}
`

	newFromReaderTemplate = `
{{range $i, $struct := .StructName}}
// New{{ $struct }}FromReader will create a {{ $struct }} from an
// io.Reader with JSON data.
func New{{ $struct }}FromReader(reader io.Reader) (*{{ $struct }}, error) {
	var {{ index $.StructNameNotExported $i }} {{ $struct }}
	err := json.NewDecoder(reader).Decode(&{{ index $.StructNameNotExported $i }})
	if err != nil && err != io.EOF {
		return nil, errors.Wrap(err, "failed to decode {{ $struct }}")
	}

	return &{{ index $.StructNameNotExported $i }}, nil
}

// New{{ index $.PluralName $i }}FromReader will create a slice of {{ index $.PluralName $i }} from an
// io.Reader with JSON data.
func New{{ index $.PluralName $i }}FromReader(reader io.Reader) ([]*{{ index $.StructName $i }}, error) {
	{{ index $.StructNameNotExportedPlural $i }} := []*{{ index $.StructName $i }}{}
	err := json.NewDecoder(reader).Decode(&{{ index $.StructNameNotExportedPlural $i }})
	if err != nil && err != io.EOF {
		return nil, errors.Wrap(err, "failed to decode {{ index $.PluralName $i }}")
	}

	return {{ index $.StructNameNotExportedPlural $i }}, nil
}
{{end}}
`

	newFromReaderTestTemplate = `
{{range $i, $struct := .StructName}}
func TestNew{{ $struct }}FromReader(t *testing.T) {
	t.Run("empty", func(t *testing.T) {
		{{ index $.StructNameNotExported $i }}, err := New{{ $struct }}FromReader(bytes.NewReader([]byte(
			"",
		)))
		require.NoError(t, err)
		require.Equal(t, &{{ $struct }}{}, {{ index $.StructNameNotExported $i }})
	})

	t.Run("invalid", func(t *testing.T) {
		{{ index $.StructNameNotExported $i }}, err := New{{ $struct }}FromReader(bytes.NewReader([]byte(
			"{test",
		)))
		require.Error(t, err)
		require.Nil(t, {{ index $.StructNameNotExported $i }})
	})

	t.Run("valid", func(t *testing.T) {
		{{ index $.StructNameNotExported $i }}, err := New{{ $struct }}FromReader(bytes.NewReader([]byte(
			TODO - fill me,
		)))
		require.NoError(t, err)
		require.Equal(t, &{{ $struct }}{TODO - fill me}, {{ index $.StructNameNotExported $i }})
	})
}

func TestNew{{ $struct }}sFromReader(t *testing.T) {
	t.Run("empty", func(t *testing.T) {
		{{ index $.StructNameNotExportedPlural $i }}, err := New{{ $struct }}sFromReader(bytes.NewReader([]byte(
			"",
		)))
		require.NoError(t, err)
		require.Equal(t, []*{{ $struct }}{}, {{ index $.StructNameNotExportedPlural $i }})
	})

	t.Run("invalid", func(t *testing.T) {
		{{ index $.StructNameNotExportedPlural $i }}, err := New{{ $struct }}sFromReader(bytes.NewReader([]byte(
			"{test",
		)))
		require.Error(t, err)
		require.Nil(t, {{ index $.StructNameNotExportedPlural $i }})
	})

	t.Run("valid", func(t *testing.T) {
		{{ index $.StructNameNotExportedPlural $i }}, err := New{{ $struct }}sFromReader(bytes.NewReader([]byte(
			TODO - fill me,
		)))
		require.NoError(t, err)
		require.Equal(t, []*{{ $struct }}{
			TODO - fill me,
		}, {{ index $.StructNameNotExportedPlural $i }})
	})
}
{{end}}

`


	)


